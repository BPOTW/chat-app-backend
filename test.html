<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tile Test â€” Floor PNG</title>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin: 18px; }
  .controls { display:flex; gap:12px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
  .panel { display:inline-block; vertical-align:top; width:48%; box-sizing:border-box; }
  .box {
    border: 1px solid #ddd;
    border-radius:8px;
    padding:10px;
    min-height:320px;
    background:#fafafa;
    box-shadow: 0 6px 18px rgba(0,0,0,0.03);
  }

  /* CSS tiled preview area */
  #cssPreview {
    height: 480px;
    border-radius:6px;
    background-position: top left;
    background-repeat: repeat;
    background-size: auto;
  }

  /* Canvas area styles */
  #canvasContainer { display:flex; justify-content:center; align-items:center; }
  canvas { image-rendering: pixelated; border-radius:6px; max-width:100%; height:auto; }

  label.small { font-size:0.9rem; color:#444; }
  input[type="range"] { width:160px; }
  .muted { color:#666; font-size:0.9rem; }
  .hint { margin-top:8px; color:#555; font-size:0.9rem; }
</style>
</head>
<body>

<h1 style="font-size:1.2rem; margin-bottom:10px;">Floor Tile Tester</h1>

<div class="controls">
  <div>
    <input id="file" type="file" accept="image/png, image/*" />
    <div class="muted">Pick your tile PNG from disk (or use the default example).</div>
  </div>

  <div>
    <label class="small">Scale: <span id="scaleLabel">1.0</span>x</label><br/>
    <input id="scale" type="range" min="0.25" max="3" step="0.05" value="1" />
  </div>

  <div>
    <label class="small">Canvas Width:</label><br/>
    <input id="canvasW" type="number" min="100" value="800" /> px
  </div>

  <div>
    <label class="small">Canvas Height:</label><br/>
    <input id="canvasH" type="number" min="100" value="480" /> px
  </div>

  <div>
    <button id="apply">Apply to Canvas</button>
  </div>
</div>

<div style="display:flex; gap:16px; flex-wrap:wrap;">
  <div class="panel">
    <div class="box">
      <strong>CSS background-repeat preview</strong>
      <div id="cssPreview" style="margin-top:10px;"></div>
      <div class="hint">This uses CSS `background-repeat`. Quick to test how your tile repeats as a floor.</div>
    </div>
  </div>

  <div class="panel">
    <div class="box">
      <strong>Canvas tiling preview</strong>
      <div id="canvasContainer" style="margin-top:10px;">
        <canvas id="tileCanvas" width="800" height="480"></canvas>
      </div>
      <div class="hint">Canvas allows precise control (scale, resolution, export). Click "Apply to Canvas" after changing size/scale.</div>
    </div>
  </div>
</div>

<script>
  const fileInput = document.getElementById('file');
  const cssPreview = document.getElementById('cssPreview');
  const canvas = document.getElementById('tileCanvas');
  const ctx = canvas.getContext('2d');
  const scaleInput = document.getElementById('scale');
  const scaleLabel = document.getElementById('scaleLabel');
  const canvasW = document.getElementById('canvasW');
  const canvasH = document.getElementById('canvasH');
  const applyBtn = document.getElementById('apply');

  // Default tile (if you don't pick a file). Replace with "tile.png" if you serve it.
  let tileSrc = 'tile.png'; // if you have a tile in same folder, it'll be used by default
  let img = new Image();
  img.crossOrigin = 'anonymous';
  img.onload = () => drawAll();
  img.onerror = () => {
    // If default not found, clear previews and wait for file
    cssPreview.style.backgroundImage = '';
    ctx.clearRect(0,0,canvas.width,canvas.height);
  };
  img.src = tileSrc;

  // When user picks a local file, load it as blob URL
  fileInput.addEventListener('change', (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const url = URL.createObjectURL(f);
    img = new Image();
    img.onload = () => {
      // Use the new image for both displays
      cssPreview.style.backgroundImage = `url(${url})`;
      drawAll();
      // release object URL when not needed (optional)
      // URL.revokeObjectURL(url);
    };
    img.src = url;
  });

  // scale range
  scaleInput.addEventListener('input', () => {
    scaleLabel.textContent = parseFloat(scaleInput.value).toFixed(2);
    // update CSS background-size for visual parity
    updateCssBackgroundSize();
  });

  // update canvas size inputs
  applyBtn.addEventListener('click', () => {
    const w = Math.max(100, parseInt(canvasW.value) || 800);
    const h = Math.max(100, parseInt(canvasH.value) || 480);
    canvas.width = w;
    canvas.height = h;
    drawAll();
  });

  function updateCssBackgroundSize() {
    // CSS version: scale the tile by scaleInput value while preserving repeat
    const s = parseFloat(scaleInput.value);
    if (!img || !img.width) return;
    const cssW = img.width * s;
    const cssH = img.height * s;
    cssPreview.style.backgroundSize = `${cssW}px ${cssH}px`;
  }

  function drawAll() {
    // CSS preview
    cssPreview.style.backgroundImage = `url(${img.src})`;
    updateCssBackgroundSize();

    // Canvas tiling
    tileCanvasDraw();
  }

  function tileCanvasDraw() {
    if (!img || !img.width) {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      return;
    }

    const s = parseFloat(scaleInput.value);
    const tileW = Math.max(1, Math.round(img.width * s));
    const tileH = Math.max(1, Math.round(img.height * s));

    // Clear canvas
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Optional: draw a subtle grid behind to show tile boundaries
    // ctx.fillStyle = '#f6f6f6';
    // ctx.fillRect(0,0,canvas.width,canvas.height);

    // For pixel-art tiles, prefer nearest neighbor scaling
    ctx.imageSmoothingEnabled = false;

    // Draw tiles in nested loops
    for (let y = 0; y < canvas.height; y += tileH) {
      for (let x = 0; x < canvas.width; x += tileW) {
        ctx.drawImage(img, x, y, tileW, tileH);
      }
    }
  }

  // Initial draw when loaded (if default tile exists)
  // If default tile isn't available, canvas will stay blank until you pick a file.
  img.addEventListener ? img.addEventListener('load', drawAll) : (img.onload = drawAll);

  // Helpful: redraw when window resizes (keeps canvas responsive visually)
  window.addEventListener('resize', () => {
    // Do not change canvas logical size, but redraw so it looks crisp if needed
    drawAll();
  });

  // Quick keyboard shortcuts
  window.addEventListener('keydown', (e) => {
    if (e.key === 'r') { // r = reset scale to 1
      scaleInput.value = 1;
      scaleLabel.textContent = '1.00';
      updateCssBackgroundSize();
      drawAll();
    }
  });
</script>
</body>
</html>
